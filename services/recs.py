import os
import logging
import asyncio
import httpx
from typing import Dict, Any, Optional, Tuple, List
from openai import AsyncOpenAI
import random

# Настройка логирования
logger = logging.getLogger(__name__)

# Проверка наличия API-ключа OpenAI
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    logger.warning("OPENAI_API_KEY не найден в переменных окружения. Будет использован режим заглушки.")

# Инициализация клиента OpenAI с API-ключом из переменных окружения (если доступен)
http_client = httpx.AsyncClient()
client = None
if OPENAI_API_KEY:
    try:
        client = AsyncOpenAI(
            api_key=OPENAI_API_KEY,
            http_client=http_client
        )
        logger.info("OpenAI API клиент успешно инициализирован в services/recs.py")
    except Exception as e:
        logger.error(f"Ошибка при инициализации OpenAI API: {e}")

# Типы намерений пользователя
USER_INTENTS = {
    "question": "вопрос пользователя на конкретную тему",
    "meditation": "запрос на медитацию или расслабление",
    "joke": "шутка или легкая беседа",
    "help": "запрос помощи или совета",
    "analysis": "запрос на анализ ситуации или проблемы",
    "greeting": "приветствие или общее начало разговора",
    "feedback": "обратная связь или реакция на предыдущее сообщение бота",
    "support": "запрос психологической поддержки"
}

# Список доступных фокусов для рекомендаций
AVAILABLE_FOCUSES = {
    "burnout": "эмоциональным выгоранием",
    "anxiety": "тревогой",
    "depression": "депрессией",
    "stress": "стрессом",
    "postpartum": "послеродовым периодом",
    "self-esteem": "низкой самооценкой",
    "grief": "горем и утратой",
    "relationship": "отношениями",
    "family": "семейными проблемами",
    "career": "карьерными вопросами",
    "motivation": "мотивацией",
    "sleep": "проблемами сна",
    "default": "повседневными трудностями"
}

# Заготовленные ответы для режима без OpenAI API
DEFAULT_RESPONSES = {
    "question": "Это интересный вопрос. Я постараюсь найти информацию по этой теме и ответить вам подробнее.",
    "meditation": "Для медитации я рекомендую найти тихое место, сесть удобно и сосредоточиться на своем дыхании. Вы также можете использовать команду /meditate для получения аудио-медитации.",
    "joke": "Рада, что у вас хорошее настроение! Продолжайте в том же духе.",
    "help": "Я здесь, чтобы помочь. Расскажите подробнее о своей ситуации, и я постараюсь предложить решение.",
    "analysis": "Для детального анализа этой ситуации мне нужно больше информации. Расскажите подробнее, что происходит?",
    "greeting": "Здравствуйте! У меня всё хорошо, спасибо, что спросили. Чем я могу вам помочь сегодня?",
    "feedback": "Спасибо за ваш отклик! Я стараюсь быть полезной.",
    "support": "Я понимаю, что вы сейчас чувствуете. Важно помнить, что вы не одни, и эти чувства временны."
}

# Дополнительные варианты ответов на приветствия
GREETING_RESPONSES = [
    "Привет! У меня всё отлично. Как я могу вам помочь сегодня?",
    "Здравствуйте! Рада вас видеть снова. Чем могу быть полезна?",
    "Добрый день! У меня всё хорошо, надеюсь, и у вас тоже. Чем я могу помочь?",
    "Приветствую! Я всегда готова помочь. Что вас интересует?",
    "Здравствуйте! Отлично, спасибо, что спросили. Как я могу быть полезной сегодня?"
]

# Заготовленные рекомендации для режима без OpenAI API
DEFAULT_RECOMMENDATIONS = {
    "burnout": "Важно распределить нагрузку и выделить время для отдыха. Попробуйте технику Помодоро — 25 минут работы, 5 минут отдыха.",
    "anxiety": "Попробуйте дыхательную технику 4-7-8: вдох на 4 счета, задержка на 7, выдох на 8. Регулярная физическая активность также значительно снижает тревожность.",
    "depression": "Составьте список маленьких дел, которые приносят вам радость, и выполняйте хотя бы одно каждый день. Общение с близкими также может улучшить состояние.",
    "stress": "Регулярные перерывы в работе помогут снизить стресс. Попробуйте медитацию или прогулку на свежем воздухе хотя бы 15 минут в день.",
    "postpartum": "Важно принять помощь близких и не стесняться просить о ней. Выделите время для себя, даже 15-20 минут могут значительно улучшить ваше состояние.",
    "self-esteem": "Ведите дневник достижений, записывая даже небольшие успехи. Избегайте сравнения себя с другими, фокусируйтесь на своем прогрессе.",
    "grief": "Дайте себе разрешение скорбеть столько, сколько нужно. Не подавляйте эмоции, поговорите о них с близкими или специалистом.",
    "relationship": "Эффективная коммуникация — ключ к здоровым отношениям. Говорите о своих чувствах, используя «я-высказывания» вместо обвинений.",
    "family": "Установите четкие границы и правила, которые работают для всех членов семьи. Выделите время для семейных активностей без гаджетов.",
    "career": "Определите свои профессиональные цели на ближайшие 3-6 месяцев. Инвестируйте время в развитие навыков, которые для них необходимы.",
    "motivation": "Разбейте большие задачи на более мелкие и достижимые. Отмечайте прогресс и награждайте себя за выполненные шаги.",
    "sleep": "Создайте вечерний ритуал без гаджетов за час до сна. Следите за регулярностью времени отхода ко сну и пробуждения.",
    "default": "Практикуйте осознанность и внимательность к своим эмоциям. Выделите время на деятельность, которая приносит вам удовольствие и помогает расслабиться."
}

# Словарь для хранения последнего времени запроса пользователя
last_request_time: Dict[int, float] = {}

async def detect_intent_and_focus(text: str) -> Tuple[str, str]:
    """
    Определяет намерение пользователя и фокус сообщения.
    
    Args:
        text: Текст сообщения пользователя.
        
    Returns:
        Tuple[str, str]: Намерение пользователя и фокус сообщения.
    """
    text_lower = text.lower()
    
    # Определение намерения по ключевым словам
    intent_markers = {
        "question": ["как", "что", "где", "когда", "почему", "зачем", "какой", "сколько", "?"],
        "meditation": ["медитация", "медитировать", "релакс", "расслабиться", "успокоиться", "медитируй"],
        "joke": ["шутка", "анекдот", "смешно", "весело", "рассмеши", "шути", "юмор"],
        "help": ["помоги", "помощь", "поддержка", "совет", "подскажи", "посоветуй"],
        "analysis": ["анализ", "разбор", "объясни", "расскажи", "проанализируй", "пойми"],
        "greeting": ["привет", "здравствуй", "добрый день", "здорова", "хай", "приветствую", "как дела", "что нового", "как жизнь", "как поживаешь", "доброе утро", "добрый вечер"],
        "feedback": ["спасибо", "благодарю", "хорошо", "отлично", "понравилось", "не понравилось"],
    }
    
    # Проверяем наличие полных фраз для приветствий
    greeting_phrases = ["как дела", "как жизнь", "как поживаешь", "что нового"]
    for phrase in greeting_phrases:
        if phrase in text_lower:
            return "greeting", "default"
    
    # Проверяем наличие маркеров интента
    detected_intent = "support"  # По умолчанию считаем, что это запрос поддержки
    for intent, markers in intent_markers.items():
        for marker in markers:
            if marker in text_lower:
                detected_intent = intent
                break
        if detected_intent != "support":
            break
    
    # Определение фокуса сообщения
    focus_keywords = {
        "burnout": ["выгорание", "выгорел", "устал", "истощение", "нет сил", "перегрузк"],
        "anxiety": ["тревога", "тревожность", "паник", "волнение", "беспокойств", "страх"],
        "depression": ["депресси", "подавлен", "грусть", "тоска", "печаль", "апатия", "нет настроения"],
        "stress": ["стресс", "напряжение", "нервы", "нервничаю", "давление"],
        "postpartum": ["после родов", "послеродов", "ребенок", "малыш", "грудное", "кормление"],
        "self-esteem": ["самооценка", "неуверенность", "комплекс", "не справляюсь", "недостаточно"],
        "grief": ["горе", "потеря", "утрата", "умер", "смерть", "скорбь"],
        "relationship": ["отношения", "партнер", "муж", "жена", "расстался", "любовь", "измена"],
        "family": ["семья", "родители", "дети", "мама", "папа", "ребенок", "конфликт"],
        "career": ["работа", "карьера", "должность", "профессия", "увольнение", "коллеги"],
        "motivation": ["мотивация", "лень", "прокрастинация", "откладываю", "не могу начать"],
        "sleep": ["сон", "бессонница", "не спится", "просыпаюсь", "недосып"]
    }
    
    detected_focus = "default"
    for focus, keywords in focus_keywords.items():
        for keyword in keywords:
            if keyword in text_lower:
                detected_focus = focus
                break
        if detected_focus != "default":
            break
    
    return detected_intent, detected_focus

async def detect_intent_with_ai(text: str) -> Tuple[str, float]:
    """
    Определяет намерение пользователя с помощью OpenAI.
    
    Args:
        text: Текст сообщения пользователя.
        
    Returns:
        Tuple[str, float]: Намерение пользователя и уверенность в определении.
    """
    if not client:
        # Если API недоступен, используем правила
        intent, _ = await detect_intent_and_focus(text)
        return intent, 0.7
    
    try:
        response = await client.chat.completions.create(
            model="gpt-4o",
            temperature=0.3,
            messages=[
                {
                    "role": "system",
                    "content": f"""Ты — чуткий и внимательный аналитик запросов пользователей проекта ONA.

Определи, какое из следующих намерений лучше всего соответствует сообщению пользователя.
Доступные намерения:
- question: вопрос пользователя на конкретную тему
- meditation: запрос на медитацию или расслабление
- joke: шутка или легкая беседа
- help: запрос помощи или совета
- analysis: запрос на анализ ситуации или проблемы
- greeting: приветствие или общее начало разговора
- feedback: обратная связь или реакция на предыдущее сообщение бота
- support: запрос психологической поддержки

Ответь только названием намерения на английском (например, "question").
"""
                },
                {
                    "role": "user",
                    "content": text
                }
            ]
        )
        
        intent = response.choices[0].message.content.strip().lower()
        
        # Проверяем, что ответ соответствует одному из возможных намерений
        if intent in USER_INTENTS:
            return intent, 0.9
        else:
            # Если ответ не соответствует, используем правила
            logger.warning(f"AI вернул неизвестное намерение: {intent}. Используем правила.")
            detected_intent, _ = await detect_intent_and_focus(text)
            return detected_intent, 0.6
            
    except Exception as e:
        error_str = str(e)
        if "quota" in error_str.lower() or "insufficient_quota" in error_str or "429" in error_str:
            logger.error(f"Ошибка квоты OpenAI API при определении намерения: {e}. Используем правила.")
        else:
            logger.error(f"Ошибка при определении намерения: {e}")
        
        # В случае ошибки используем правила
        detected_intent, _ = await detect_intent_and_focus(text)
        return detected_intent, 0.5

async def generate_response(text: str, user_id: int) -> str:
    """
    Генерирует контекстуальный ответ на сообщение пользователя с использованием OpenAI.
    
    Args:
        text: Текст сообщения пользователя.
        user_id: ID пользователя в Telegram.
        
    Returns:
        str: Сгенерированный ответ.
    """
    # Проверка антиспам-защиты
    current_time = asyncio.get_event_loop().time()
    if user_id in last_request_time:
        time_diff = current_time - last_request_time[user_id]
        if time_diff < 2:  # Не чаще одного раза в 2 секунды
            wait_time = round(2 - time_diff, 1)
            return f"Пожалуйста, подождите {wait_time} сек. перед следующим запросом."
    
    # Обновляем время последнего запроса
    last_request_time[user_id] = current_time
    
    # Определяем намерение пользователя и фокус сообщения
    intent, confidence = await detect_intent_with_ai(text)
    _, focus = await detect_intent_and_focus(text)
    
    logger.info(f"Определено намерение: {intent} с уверенностью {confidence}. Фокус: {focus}")
    
    # Если API-ключ OpenAI не настроен или клиент не инициализирован
    use_default_response = not client
    
    try:
        # Если не используем OpenAI, возвращаем заготовленный ответ
        if use_default_response:
            logger.warning("OpenAI API недоступен для генерации ответа, используем заготовки")
            if intent == "support":
                return DEFAULT_RECOMMENDATIONS.get(focus, DEFAULT_RECOMMENDATIONS["default"])
            elif intent == "greeting":
                # Для приветствий выбираем случайный ответ из заготовленных
                return random.choice(GREETING_RESPONSES)
            else:
                return DEFAULT_RESPONSES.get(intent, DEFAULT_RESPONSES["support"])
        
        # Создаем запрос к OpenAI в зависимости от намерения
        if intent == "question":
            system_prompt = """Ты — чуткий и поэтичный AI-собеседник проекта ONA. Ты даёшь глубокие, ясные ответы на вопросы, используя мягкий, поддерживающий тон. Твои ответы должны быть информативными, но не сухими — добавляй образность и метафоры, сохраняя научную точность. Обращайся к пользователю на «ты». Ответ должен быть на русском языке."""
        elif intent == "meditation":
            system_prompt = """Ты — чуткий и поэтичный наставник по медитации проекта ONA. Создай атмосферу спокойствия и присутствия через свои слова. Предложи пользователю короткую технику медитации или расслабления, используя плавный, размеренный темп повествования. Обращайся к пользователю на «ты». Ответ должен быть на русском языке."""
        elif intent == "joke":
            system_prompt = """Ты — дружелюбный и остроумный собеседник проекта ONA с чувством юмора. Твои шутки должны быть лёгкими и тонкими, без сарказма и негатива. Обращайся к пользователю на «ты». Ответ должен быть на русском языке."""
        elif intent == "help":
            system_prompt = """Ты — внимательный и заботливый наставник проекта ONA. Предложи конкретные, практичные шаги для решения проблемы пользователя. Будь поддерживающим, но избегай пустых утешений — предлагай действенные стратегии. Обращайся к пользователю на «ты». Ответ должен быть на русском языке."""
        elif intent == "analysis":
            system_prompt = """Ты — вдумчивый аналитик проекта ONA. Твоя задача — глубоко проанализировать ситуацию, о которой говорит пользователь, выявляя скрытые связи и смыслы. Используй структурированный подход, но избегай излишней академичности — твой анализ должен быть понятным и применимым. Обращайся к пользователю на «ты». Ответ должен быть на русском языке."""
        elif intent == "greeting":
            system_prompt = """Ты — тёплый и искренний собеседник проекта ONA. Ответь на приветствие пользователя душевно и естественно, как близкий друг. Избегай формальностей и шаблонных фраз. Создай ощущение реального, живого диалога. Обращайся к пользователю на «ты». Ответ должен быть на русском языке и не более 1-2 предложений."""
        elif intent == "feedback":
            system_prompt = """Ты — внимательный и благодарный собеседник проекта ONA. Искренне поблагодари пользователя за обратную связь, показывая, что его мнение действительно ценно и будет учтено. Будь открытым и неформальным в общении. Обращайся к пользователю на «ты». Ответ должен быть на русском языке."""
        else:  # support
            focus_description = AVAILABLE_FOCUSES[focus]
            system_prompt = f"""Ты — чуткий и поэтичный психолог-наставник проекта ONA. Дай 1–2 коротких, практических и вдохновляющих совета для поддержки пользователя с фокусом: {focus_description}. Используй образный язык и метафоры, помогая увидеть ситуацию в новом свете. Твои слова должны согревать и придавать сил. Обращайся к пользователю на «ты». Ответ должен быть на русском языке, не более 3-4 предложений, без введения и заключения."""
        
        try:
            response = await client.chat.completions.create(
                model="gpt-4o",
                temperature=0.7,
                messages=[
                    {
                        "role": "system",
                        "content": system_prompt
                    },
                    {
                        "role": "user",
                        "content": text
                    }
                ]
            )
            
            # Получаем результат
            result = response.choices[0].message.content.strip()
            logger.info(f"Сгенерирован ответ для пользователя {user_id} с намерением '{intent}' и фокусом '{focus}'")
            
            return result
        except Exception as e:
            error_str = str(e)
            if "quota" in error_str.lower() or "insufficient_quota" in error_str or "429" in error_str:
                logger.error(f"Ошибка квоты OpenAI API при генерации ответа: {e}. Используем заготовленный ответ.")
                use_default_response = True
            else:
                logger.error(f"Ошибка при генерации ответа: {e}")
                raise e
        
    except Exception as e:
        logger.error(f"Общая ошибка при генерации ответа: {e}")
        use_default_response = True
    
    # В случае ошибки или если API недоступен, используем заготовленный ответ
    if use_default_response:
        if intent == "support":
            return DEFAULT_RECOMMENDATIONS.get(focus, DEFAULT_RECOMMENDATIONS["default"])
        elif intent == "greeting":
            # Для приветствий выбираем случайный ответ из заготовленных
            return random.choice(GREETING_RESPONSES)
        else:
            return DEFAULT_RESPONSES.get(intent, DEFAULT_RESPONSES["support"])

# Устаревшая функция, сохраняем для обратной совместимости
async def generate_recommendation(text: str, user_id: int, focus: str = "default") -> str:
    """
    Генерация персонализированной рекомендации для пользователя с использованием OpenAI.
    Устаревшая функция, используйте generate_response.
    """
    logger.warning("Использование устаревшей функции generate_recommendation. Рекомендуется перейти на generate_response.")
    return await generate_response(text, user_id)

# Устаревшая функция, сохраняем для обратной совместимости
def detect_focus(text: str) -> Optional[str]:
    """
    Определяет фокус рекомендации на основе текста пользователя.
    Устаревшая функция, используйте detect_intent_and_focus.
    """
    logger.warning("Использование устаревшей функции detect_focus. Рекомендуется перейти на detect_intent_and_focus.")
    _, focus = asyncio.run(detect_intent_and_focus(text))
    return focus 
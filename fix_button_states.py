#!/usr/bin/env python
"""
Скрипт для проверки и восстановления button_states.py, если файл отсутствует или некорректен.
Будет запускаться автоматически перед стартом бота в Railway.
"""

import os
import sys
import logging
import shutil

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - [BUTTON_STATES_FIX] - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("fix_button_states")

def check_and_fix_button_states():
    """
    Проверяет наличие и корректность файла button_states.py.
    При необходимости восстанавливает его из резервной копии.
    """
    # Проверка наличия основного файла
    target_file = "button_states.py"
    backup_file = "backup_button_states.py"
    
    logger.info(f"Проверка файла {target_file}...")
    
    # Если backup файл не существует, создать пустой файл
    if not os.path.exists(backup_file):
        logger.warning(f"Файл {backup_file} не найден, создание базовой версии...")
        create_default_backup()
    
    # Если основной файл не существует или пустой
    if not os.path.exists(target_file) or os.path.getsize(target_file) == 0:
        logger.warning(f"Файл {target_file} не найден или пустой, восстановление из резервной копии...")
        restore_from_backup()
        return
    
    # Проверка содержимого основного файла
    try:
        with open(target_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Проверка наличия необходимых классов и методов
        if 'class ProfileStates' not in content or 'viewing = State()' not in content:
            logger.warning(f"Файл {target_file} не содержит необходимых классов или методов, восстановление из резервной копии...")
            restore_from_backup()
        else:
            logger.info(f"Файл {target_file} содержит все необходимые классы и методы")
    except Exception as e:
        logger.error(f"Ошибка при проверке файла {target_file}: {e}")
        logger.warning(f"Восстановление из резервной копии...")
        restore_from_backup()

def restore_from_backup():
    """
    Восстанавливает button_states.py из резервной копии.
    """
    target_file = "button_states.py"
    backup_file = "backup_button_states.py"
    
    try:
        # Проверяем существование backup файла
        if not os.path.exists(backup_file):
            logger.error(f"Резервная копия {backup_file} не найдена, создание базовой версии...")
            create_default_backup()
        
        # Восстановление из резервной копии
        shutil.copy2(backup_file, target_file)
        logger.info(f"Файл {target_file} успешно восстановлен из резервной копии")
        
        # Проверка результата
        if os.path.exists(target_file) and os.path.getsize(target_file) > 0:
            logger.info(f"Проверка восстановленного файла: OK (размер: {os.path.getsize(target_file)} байт)")
        else:
            logger.error(f"Ошибка восстановления: файл {target_file} не существует или пустой")
    except Exception as e:
        logger.error(f"Ошибка при восстановлении файла {target_file}: {e}")

def create_default_backup():
    """
    Создает базовую версию backup_button_states.py.
    """
    backup_file = "backup_button_states.py"
    
    try:
        with open(backup_file, 'w', encoding='utf-8') as f:
            f.write("""# Default backup of button_states.py generated by fix_button_states.py
# This file is used to ensure ProfileStates class is available
from aiogram.fsm.state import State, StatesGroup

class SurveyStates(StatesGroup):
    \"\"\"
    Состояния для опроса пользователя.
    \"\"\"
    answering_questions = State()  # Пользователь отвечает на вопросы опроса

class ProfileStates(StatesGroup):
    \"\"\"
    Состояния для работы с профилем пользователя.
    \"\"\"
    viewing = State()  # Пользователь просматривает свой профиль
    editing = State()  # Пользователь редактирует свой профиль

class MeditationStates(StatesGroup):
    \"\"\"
    Состояния для работы с медитациями.
    \"\"\"
    selecting_type = State()  # Пользователь выбирает тип медитации
    waiting_for_generation = State()  # Ожидание генерации аудио-медитации

class ReminderStates(StatesGroup):
    \"\"\"
    Состояния для работы с напоминаниями.
    \"\"\"
    main_menu = State()      # Главное меню напоминаний
    selecting_days = State()  # Пользователь выбирает дни для напоминаний
    selecting_time = State()  # Пользователь выбирает время для напоминаний
    confirming = State()  # Пользователь подтверждает настройки напоминаний
""")
        logger.info(f"Создана базовая версия файла {backup_file}")
    except Exception as e:
        logger.error(f"Ошибка при создании базовой версии файла {backup_file}: {e}")

if __name__ == "__main__":
    print("=" * 50)
    print("ЗАПУСК ПРОВЕРКИ И ВОССТАНОВЛЕНИЯ BUTTON_STATES.PY")
    print("=" * 50)
    
    check_and_fix_button_states()
    
    print("=" * 50)
    print("ЗАВЕРШЕНИЕ ПРОВЕРКИ И ВОССТАНОВЛЕНИЯ BUTTON_STATES.PY")
    print("=" * 50) 